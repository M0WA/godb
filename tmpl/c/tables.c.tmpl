/* ==============================================================
   this is generated code, changes will be overwritten
   ============================================================== */

#include "tables.h"

#include <string.h>
#include <stdlib.h>

#include "db.h"
#include "column.h"
#include "table.h"
#include "statements.h"
#include "keys.h"
{{ $td := . }}{{ $layout := .L }}{{ range $db := .L.Databases }}{{ range $tbl := $db.Tables }}
// {{ $db.Name }}.{{ $tbl.Name }}: column definitions
const struct _DBColumnDef coldefs_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $col := $tbl.Columns }}
	(struct _DBColumnDef) { 
		.type = COL_TYPE_{{ $col.DataType | ToUpper }},
		.name = "{{ $col.Name }}",
		.table = "{{ $tbl.Name }}",
		.database = "{{ $db.Name }}",
		.size = {{ $td.SizeOf $col }},
		.autoincrement = {{ if $col.AutoIncrement }}1{{ else }}0{{ end }},
		.notnull = {{ if $col.NotNull }}1{{ else }}0{{ end }},
		.notsigned = {{ if $col.Unsigned }}1{{ else }}0{{ end }},
	},{{ end }}{{/* columns */}}
}; 
{{ end }}{{ end }}{{ range $db := .L.Databases }}{{ range $tbl := $db.Tables }}{{ $nuniq := len $tbl.UniqueKeys }}{{ $nforeign := len $tbl.ForeignKeys }}{{ $nindex := len $tbl.IndexKeys }}{{ if gt $nforeign 0 }} 
// {{ $db.Name }}.{{ $tbl.Name }}: foreign keys
const struct _ForeignKey foreigns_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $iforeign,$foreign := $tbl.ForeignKeys }}
	(struct _ForeignKey){ 
		.col = {{ range $iftbl,$ftblcol := $tbl.Columns }}{{ if eq $foreign.Column $ftblcol.Name }}&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $iftbl }}]), //{{ $ftblcol.Name }}{{ end }}{{ end }}
		.ref = {{ range $fdb := $layout.Databases }}{{ range $ftbl := $fdb.Tables }}{{ if eq $foreign.RefTable $ftbl.Name }}{{ range $iftbl,$ftblcol := $ftbl.Columns }}{{ if eq $foreign.RefColumn $ftblcol.Name }}&(coldefs_{{ $fdb.Name }}_{{ $ftbl.Name }}[{{ $iftbl }}]), //{{ $ftblcol.Name }}{{ end }}{{ end }}{{ end }}{{ end }}{{ end }} 
	}, {{ end }}
};
{{ end }}{{ if gt $nindex 0 }}
// {{ $db.Name }}.{{ $tbl.Name }}: index keys
const struct _IndexKey indexkeys_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $iindex,$index := $tbl.IndexKeys }}
	(struct _IndexKey) {
		.col = {{ range $itbl,$itblcol := $tbl.Columns }}{{ if eq $index.Column $itblcol.Name }}&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $itbl }}]), //{{ $itblcol.Name }}{{ end }}{{ end }},
	}, {{ end }}
};
{{ end }}{{ if gt $nuniq 0 }} 
// {{ $db.Name }}.{{ $tbl.Name }}: unique key definitions {{ range $iuniq,$uniq := $tbl.UniqueKeys }}
const struct _DBColumnDef* uniqdef_{{ $db.Name }}_{{ $tbl.Name }}_{{ $iuniq }}[] = { {{ range $uniqcol := $uniq.Columns }}{{ range $itblcol,$tblcol := $tbl.Columns }}{{ if eq $tblcol.Name $uniqcol }}
	&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $itblcol }}]), //{{ $uniqcol }}	{{ end }}{{ end }}{{ end }} 
};{{ end }}

// {{ $db.Name }}.{{ $tbl.Name }}: unique keys
const struct _UniqKey uniqs_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $iuniq,$uniq := $tbl.UniqueKeys }}
	{
		.ncols = {{ len $uniq.Columns }},
		.cols = (const struct _DBColumnDef**)uniqdef_{{ $db.Name }}_{{ $tbl.Name }}_{{ $iuniq }}, 
	}, {{ end }}
};
{{ end }}
// {{ $db.Name }}.{{ $tbl.Name }}: table definition
const struct _DBTableDef def_{{ $db.Name }}_{{ $tbl.Name }} = (struct _DBTableDef) {
	.name = "{{ $tbl.Name }}",
	.database = "{{ $db.Name }}",
	.cols = (const struct _DBColumnDef*)&coldefs_{{ $db.Name }}_{{ $tbl.Name }},
	.ncols = {{ len $tbl.Columns }},
	.primarykey = {{ range $i,$col := $tbl.Columns }}{{ if eq $col.Name $tbl.PrimaryKey.Column }}&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $i }}]){{ end }}{{ end }},
	.uniquekeys = {{ if gt $nuniq 0 }}(const struct _UniqKey*)&uniqs_{{ $db.Name }}_{{ $tbl.Name }}{{ else }}0{{ end }},
	.nunique = {{ $nuniq }},
	.foreignkeys = {{ if gt $nforeign 0 }}(const struct _ForeignKey*)&foreigns_{{ $db.Name }}_{{ $tbl.Name }}{{ else }}0{{ end }},
	.nforeign = {{ $nforeign }},
	.indexkeys = {{ if gt $nindex 0 }}(const struct _IndexKey*)&indexkeys_{{ $db.Name }}_{{ $tbl.Name }}{{ else }}0{{ end }},
	.nindex = {{ $nindex }},
};

// {{ $db.Name }}.{{ $tbl.Name }}: create/initialize table structure
int create_{{ $db.Name }}_{{ $tbl.Name }}({{ $db.Name }}_{{ $tbl.Name }} *tbl, size_t rows) {	
	memset(tbl,0,sizeof(struct _{{ $db.Name }}_{{ $tbl.Name }}));	
	return create_dbtable(&tbl->dbtbl,&def_{{ $db.Name }}_{{ $tbl.Name }},rows);
}

const struct _DBTableDef* {{ $db.Name }}_{{ $tbl.Name }}_tbldef() {
	return &def_{{ $db.Name }}_{{ $tbl.Name }};
}
{{ range $colidx,$col := $tbl.Columns }}
void {{ $db.Name }}_{{ $tbl.Name }}_unset_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	{{ $db.Name }}_{{ $tbl.Name }}_setnull_{{ $col.Name }}(t,row);
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 0;
}

void {{ $db.Name }}_{{ $tbl.Name }}_setnull_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	if(!t->dbtbl.rows.buf[row][{{  $colidx }}]) {
		return; }
	free(t->dbtbl.rows.buf[row][{{  $colidx }}]);
	t->dbtbl.rows.buf[row][{{  $colidx }}] = 0;
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 1;
}

{{ $td.PtrType $col }} {{ $db.Name }}_{{ $tbl.Name }}_set_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 1;
	return ({{ $td.PtrType $col }})set_dbtable_columnbuf(&t->dbtbl, row, {{  $colidx }});
}

const {{ $td.PtrType $col }} {{ $db.Name }}_{{ $tbl.Name }}_get_{{ $col.Name }}(const {{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	return t->dbtbl.rows.isset[row][{{  $colidx }}] ? (const {{ $td.PtrType $col }})t->dbtbl.rows.buf[row][{{  $colidx }}] : 0;
} {{ end }}{{/* columns */}}
{{ range $i,$idx := $tbl.IndexKeys }}
int {{ $db.Name }}_{{ $tbl.Name }}_getidx_{{ $idx.Column }}() {
	return 0;
} {{ end }}{{/* indexkeys */}}
{{ end }}{{/* tables */}}{{ end }}{{/* databases */}}