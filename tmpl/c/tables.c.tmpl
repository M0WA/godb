/* ==============================================================
   this is generated code, changes will be overwritten
   ============================================================== */

#include "tables.h"

#include <string.h>
#include <stdlib.h>

#include "db.h"
#include "column.h"
#include "table.h"
#include "statements.h"
#include "keys.h"
{{ $td := . }}{{ range $db := .L.Databases }}{{ range $tbl := $db.Tables }}
/* ********************** table {{ $db.Name }}.{{ $tbl.Name }} ************************* */{{ $nuniq := len $tbl.UniqueKeys }}

// {{ $db.Name }}.{{ $tbl.Name }}: column definitions
const struct _DBColumnDef coldefs_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $col := $tbl.Columns }}
	(struct _DBColumnDef) { 
		.type = COL_TYPE_{{ $col.DataType | ToUpper }},
		.name = "{{ $col.Name }}",
		.table = "{{ $tbl.Name }}",
		.database = "{{ $db.Name }}",
		.size = {{ $td.SizeOf $col }},
		.autoincrement = {{ if $col.AutoIncrement }}1{{ else }}0{{ end }},
		.notnull = {{ if $col.NotNull }}1{{ else }}0{{ end }},
		.notsigned = {{ if $col.Unsigned }}1{{ else }}0{{ end }},
	},{{ end }}{{/* columns */}}
};
{{ if gt $nuniq 0 }} {{ range $iuniq,$uniq := $tbl.UniqueKeys }}
const struct _DBColumnDef* uniqdef_{{ $db.Name }}_{{ $tbl.Name }}_{{ $iuniq }}[] = { {{ range $uniqcol := $uniq.Columns }}{{ range $itblcol,$tblcol := $tbl.Columns }}{{ if eq $tblcol.Name $uniqcol }}
	&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $itblcol }}]), //{{ $uniqcol }}	{{ end }}{{ end }}{{ end }} 
};
{{ end }}
// {{ $db.Name }}.{{ $tbl.Name }}: unique keys
const struct _UniqKey uniqs_{{ $db.Name }}_{{ $tbl.Name }}[] = { {{ range $iuniq,$uniq := $tbl.UniqueKeys }}
	{
		.ncols = {{ len $uniq.Columns }},
		.cols = (const struct _DBColumnDef**)uniqdef_{{ $db.Name }}_{{ $tbl.Name }}_{{ $iuniq }}, 
	}, {{ end }}
};
{{ end }}
// {{ $db.Name }}.{{ $tbl.Name }}: table definition
const struct _DBTableDef def_{{ $db.Name }}_{{ $tbl.Name }} = (struct _DBTableDef) {
	.name = "{{ $tbl.Name }}",
	.database = "{{ $db.Name }}",
	.cols = (const struct _DBColumnDef*)&coldefs_{{ $db.Name }}_{{ $tbl.Name }},
	.ncols = {{ len $tbl.Columns }},
	.primarykey = {{ range $i,$col := $tbl.Columns }}{{ if eq $col.Name $tbl.PrimaryKey.Column }}&(coldefs_{{ $db.Name }}_{{ $tbl.Name }}[{{ $i }}]){{ end }}{{ end }},
	.uniquekeys = {{ if gt $nuniq 0 }}(const struct _UniqKey*)&uniqs_{{ $db.Name }}_{{ $tbl.Name }}{{ else }}0{{ end }},
	.nunique = {{ $nuniq }},
};

// {{ $db.Name }}.{{ $tbl.Name }}: create/initialize table structure
int create_{{ $db.Name }}_{{ $tbl.Name }}({{ $db.Name }}_{{ $tbl.Name }} *tbl, size_t rows) {	
	memset(tbl,0,sizeof(struct _{{ $db.Name }}_{{ $tbl.Name }}));	
	return create_dbtable(&tbl->dbtbl,&def_{{ $db.Name }}_{{ $tbl.Name }},rows);
}

const struct _DBTableDef* {{ $db.Name }}_{{ $tbl.Name }}_tbldef() {
	return &def_{{ $db.Name }}_{{ $tbl.Name }};
}
{{ range $colidx,$col := $tbl.Columns }}
void {{ $db.Name }}_{{ $tbl.Name }}_unset_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	{{ $db.Name }}_{{ $tbl.Name }}_setnull_{{ $col.Name }}(t,row);
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 0;
}

void {{ $db.Name }}_{{ $tbl.Name }}_setnull_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	if(!t->dbtbl.rows.buf[row][{{  $colidx }}]) {
		return; }
	free(t->dbtbl.rows.buf[row][{{  $colidx }}]);
	t->dbtbl.rows.buf[row][{{  $colidx }}] = 0;
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 1;
}

{{ $td.PtrType $col }} {{ $db.Name }}_{{ $tbl.Name }}_set_{{ $col.Name }}({{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	t->dbtbl.rows.isset[row][{{  $colidx }}] = 1;
	return ({{ $td.PtrType $col }})set_dbtable_columnbuf(&t->dbtbl, row, {{  $colidx }});
}

const {{ $td.PtrType $col }} {{ $db.Name }}_{{ $tbl.Name }}_get_{{ $col.Name }}(const {{ $db.Name }}_{{ $tbl.Name }} *t,size_t row) {
	return t->dbtbl.rows.isset[row][{{  $colidx }}] ? (const {{ $td.PtrType $col }})t->dbtbl.rows.buf[row][{{  $colidx }}] : 0;
}
{{ end }}{{/* columns */}}
{{ end }}{{/* tables */}}{{ end }}{{/* databases */}}