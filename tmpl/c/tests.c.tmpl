#ifdef _DB_TEST_VERSION

#include "tests.h"

#include <stdlib.h>
#include <string.h>

#include "db.h"
#include "table.h"
#include "column.h"
#include "tables.h"
#include "statements.h"
#include "selectresult.h"
#include "logger.h"
#include "keys.h"

{{ $td := . }}{{ range $db := $td.L.Databases }}{{ range $tbl := $db.Tables }}
static void test_table_upsert_{{ $db.Name }}_{{ $tbl.Name }}(DBHandle *dbh) {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} upsert");

	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);
}

static void test_table_update_{{ $db.Name }}_{{ $tbl.Name }}(DBHandle *dbh) {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} update");

	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);

	int id = 10;

	struct _WhereCondition cond;
	memset(&cond,0,sizeof(struct _WhereCondition));
	cond.cond = WHERE_NOT_EQUAL;
	cond.type = WHERE_COND;
	cond.def = &(tbl.dbtbl.def->cols[0]);
	cond.values = (const void*[]){&id};
	cond.cnt = 1;

	double testfloat = 11.11;
	UpdateStmt stmt;
	memset(&stmt,0,sizeof(UpdateStmt));
	stmt.defs = &(tbl.dbtbl.def->cols[4]);
	stmt.ncols = 1;
	stmt.valbuf = (const void*[]){&testfloat};

	if( where_append(&stmt.where,(union _WhereStmt *)&cond) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: cannot append where stmt"); }

	if(update_db(dbh,&stmt)) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: error while update"); }

	DESTROY_STMT(&stmt);
}

static void test_table_delete_{{ $db.Name }}_{{ $tbl.Name }}(DBHandle *dbh) {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} delete");

	DeleteStmt stmt;
	deletestmt_{{ $db.Name }}_{{ $tbl.Name }}(&stmt);

	int id = 10;

	struct _WhereCondition cond;
	memset(&cond,0,sizeof(struct _WhereCondition));
	cond.cond = WHERE_NOT_EQUAL;
	cond.type = WHERE_COND;
	cond.def = &(stmt.def->cols[0]);
	cond.values = (const void*[]){&id};
	cond.cnt = 1;

	if( where_append(&stmt.where,(union _WhereStmt *)&cond) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: cannot append where stmt"); }

	if(delete_db(dbh,&stmt)) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: error while delete"); }

	DESTROY_STMT(&stmt);
}

static void test_table_check_selectresult_{{ $db.Name }}_{{ $tbl.Name }}(SelectResult *res) {
	for(size_t col = 0; col < res->ncols; col++) {
		if( strcasecmp(res->cols[col].name,"ID") == 0 ) {
			if( (*(unsigned long long*)res->row[col]) == 0 ) {
				LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid ID in select result");	}
		} else if( strcasecmp(res->cols[col].name,"testint") == 0 ) {
			if( (*(long long*)res->row[col]) != 10 ) {
				LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid testint in select result: %ld",*((long long*)res->row[col])); }
		} else if( strcasecmp(res->cols[col].name,"testfloat") == 0 ) {
			if( (*(double*)res->row[col]) != 10.10 ) {
				LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid testfloat in select result"); }
		} else if( strcasecmp(res->cols[col].name,"teststr") == 0 ) {
			if( strcmp(res->row[col],"test") != 0 ) {
				LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid teststr in select result"); }
		}
	}
}

static void test_table_select_{{ $db.Name }}_{{ $tbl.Name }}(DBHandle *dbh) {
	int rc = 0;
	size_t rowcount = 0;
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} select");

	SelectStmt stmt;
	selectstmt_{{ $db.Name }}_{{ $tbl.Name }}(&stmt);

	char test[] = "test";

	struct _WhereCondition cond;
	memset(&cond,0,sizeof(struct _WhereCondition));
	cond.cond = WHERE_EQUAL;
	cond.type = WHERE_COND;
	cond.def = &(stmt.defs[1]);
	cond.values = (const void*[]){&test};
	cond.cnt = 1;

	if( where_append(&stmt.where,(union _WhereStmt *)&cond) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: cannot append where stmt"); }

	SelectResult res;
	memset(&res,0,sizeof(res));
	if( select_db(dbh,&stmt,&res) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: error while select"); }

	while( (rc = fetch_db(dbh,&res)) > 0){
		char *buf = 0;
		dump_selectresult(&res,&buf);
		if(buf) {
			LOGF_DEBUG("%s",buf);
			free(buf); }
		test_table_check_selectresult_{{ $db.Name }}_{{ $tbl.Name }}(&res);
		rowcount++;
	}
	LOGF_DEBUG("fetched %lu rows",rowcount);
	if(rc != 0 || rowcount != 4) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: error while fetch: rows: %lu, rc: %d",rowcount,rc); }

	DESTROY_STMT( (&stmt) );
	destroy_selectresult(&res);
}

int serial{{ $db.Name }}{{ $tbl.Name }} = 0;

static void test_table_columnpreset_{{ $db.Name }}_{{ $tbl.Name }}({{ $db.Name }}_{{ $tbl.Name }}* tbl) { {{ range $i,$col := $tbl.Columns }}{{ if eq $col.AutoIncrement false }}
	{{ $td.DataVar $col (printf "t%s" $col.Name) }}{{ if eq $col.Name "testuniq" }};
	char tmp{{ $db.Name }}{{ $tbl.Name }}{{ $col.Name }}[200] = {0};
	time_t t;
	struct tm *tmp;
	t = time(NULL);
	tmp = localtime(&t);
	strftime(tmp{{ $db.Name }}{{ $tbl.Name }}{{ $col.Name }}, sizeof(tmp{{ $db.Name }}{{ $tbl.Name }}{{ $col.Name }}), "%F %T", tmp);
	snprintf(t{{ $col.Name }}, sizeof(t{{ $col.Name }}),"%s %d",tmp{{ $db.Name }}{{ $tbl.Name }}{{ $col.Name }},serial{{ $db.Name }}{{ $tbl.Name }});
	SET_COLUMN_STRING((*tbl),{{ $col.Name }},t{{ $col.Name }});
	serial{{ $db.Name }}{{ $tbl.Name }}++;
	{{ else if eq $col.DataType "string" }};
	sprintf(t{{ $col.Name }},"test");
	SET_COLUMN_STRING((*tbl),{{ $col.Name }},t{{ $col.Name }});
	{{ else if eq $col.DataType "datetime" }};
	time_t tt{{ $col.Name }} = time(0);
	memset(&t{{ $col.Name }},0,sizeof(struct tm));
	gmtime_r(&tt{{ $col.Name }},&t{{ $col.Name }});
	SET_COLUMN_TM((*tbl),{{ $col.Name }},t{{ $col.Name }});
	{{ else if eq $col.DataType "float" }} = 10.10;
	SET_COLUMN((*tbl),{{ $col.Name }},t{{ $col.Name }});
	{{ else if eq $col.DataType "int" }} = 10;
	SET_COLUMN((*tbl),{{ $col.Name }},t{{ $col.Name }});
	{{ end }}{{/* end if */}}{{ end }}{{/* end if */}}{{ end }}{{/* columns */}}
}

static void test_table_checkpreset_{{ $db.Name }}_{{ $tbl.Name }}(const {{ $db.Name }}_{{ $tbl.Name }}* tbl) { {{ range $i,$col := $tbl.Columns }}{{ if eq $col.AutoIncrement false }}
	if( !tbl->tbl.colptr.{{ $col.Name }} ) {
	 	LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: null value column"); }
	{{ if eq $col.Name "testuniq" }}
	{{ else if eq $col.DataType "datetime" }}
	if (tbl->tbl.colptr.{{ $col.Name }}->tm_year < 100 || tbl->tbl.colptr.{{ $col.Name }}->tm_year > 1000) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: invalid datetime value: %lu-%lu-%lu",tbl->tbl.colptr.{{ $col.Name }}->tm_year,tbl->tbl.colptr.{{ $col.Name }}->tm_mon,tbl->tbl.colptr.{{ $col.Name }}->m_day); }
	{{ else if eq $col.DataType "string" }}
	if( strcmp(tbl->tbl.colptr.{{ $col.Name }},"test") != 0 ){
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: invalid value: %s",tbl->tbl.{{ $col.Name }}); }
	{{ else if eq $col.DataType "int" }}
	if( *(tbl->tbl.colptr.{{ $col.Name }}) != 10 ) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: invalid value: %d",*tbl->tbl.{{ $col.Name }}); }
	{{ else if eq $col.DataType "float" }}
	if( *(tbl->tbl.colptr.{{ $col.Name }}) != 10.10 ) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: invalid value: %f",*tbl->tbl.{{ $col.Name }}); } {{ end }}{{/* end if */}}
	if( tbl->tbl.colptr.{{ $col.Name }} != tbl->dbtbl.valbuf[{{ $i }}] ) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.colptr.{{ $col.Name }}: invalid dbtable ptr: %p != %p",tbl->tbl.colptr.{{ $col.Name }},tbl->dbtbl.valbuf[{{ $i }}]); }
	{{ end }}{{/* end if */}}{{ end }}{{/* columns */}}
}

static void test_table_insert{{ $db.Name }}_{{ $tbl.Name }}(DBHandle *dbh) {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} single row insert");

	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);
	test_table_columnpreset_{{ $db.Name }}_{{ $tbl.Name }}(&tbl);

	if( INSERT_ONE_DBTABLE(dbh,&tbl.dbtbl) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: single table insert failed"); }

	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} multi row insert");
	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl2);
	test_table_columnpreset_{{ $db.Name }}_{{ $tbl.Name }}(&tbl2);

	DBTable* rows[2] = { &(tbl.dbtbl), &(tbl2.dbtbl) };
	const struct _DBTable *const*const rowp = (const struct _DBTable *const*const)&rows;
	if( insert_dbtable(dbh,rowp,2) ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: multi table insert failed"); }
}

static void test_table_def_{{ $db.Name }}_{{ $tbl.Name }}(const struct _DBTableDef* def) {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} definition");
	if(!def) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: definition is null");}
	if(!def->name || strcmp(def->name,"{{ $tbl.Name }}") != 0) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: def->name: invalid table name: %s",def->name ? def->name : "NULL");}
	if(!def->database || strcmp(def->database,"{{ $db.Name }}") != 0) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: def->database: invalid db name");}
	if(def->ncols != {{ len $tbl.Columns }}) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: def->ncols: invalid column count");}
	if(!def->cols) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: def->cols is NULL");}
}

static void test_table_buffer_size_{{ $db.Name }}_{{ $tbl.Name }}() {
	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} buffer size");
	const size_t bufsize = 0{{ range $i,$col := $tbl.Columns }} + {{ $td.SizeOf $col  }}{{ end }};
	const size_t ssize = sizeof(struct _valbuf_{{ $db.Name }}_{{ $tbl.Name }});
	if( bufsize != ssize ) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: tbl.valbuf: invalid size %d != %d",bufsize,ssize); }
}

static void test_table_indexes_{{ $db.Name }}_{{ $tbl.Name }}(const {{ $db.Name }}_{{ $tbl.Name }}* tbl) { {{ range $i,$col := $tbl.Columns }}
	LOG_DEBUG("checking column {{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }} indexes");
	if( !tbl->tbl.def->cols[{{ $i }}].name
	 || strcmp(tbl->tbl.def->cols[{{ $i }}].name,"{{ $col.Name }}") != 0 ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl->tbl.def->cols: invalid column for index"); } {{ end }}{{/* columns */}}
}

static void test_table_coldef_{{ $db.Name }}_{{ $tbl.Name }}(const {{ $db.Name }}_{{ $tbl.Name }}* tbl) { {{ range $i,$col := $tbl.Columns }}
	LOG_DEBUG("checking column {{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }} definitions");
	if( !tbl->tbl.def->cols[{{ $i }}].name || strcmp(tbl->tbl.def->cols[{{ $i }}].name,"{{ $col.Name }}") != 0) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl->tbl.def->cols: invalid column name"); }
	if( !tbl->tbl.def->cols[{{ $i }}].table || strcmp(tbl->tbl.def->cols[{{ $i }}].table,"{{ $tbl.Name }}") != 0) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl->tbl.def->cols: invalid table name"); }
	if( !tbl->tbl.def->cols[{{ $i }}].database || strcmp(tbl->tbl.def->cols[{{ $i }}].database,"{{ $db.Name }}") != 0) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl->tbl.def->cols: invalid database name"); } {{ end }}{{/* columns */}}
}

static void test_table_getset_{{ $db.Name }}_{{ $tbl.Name }}() {
	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);
	{{ range $i,$col := $tbl.Columns }}
	LOG_DEBUG("checking column {{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }} getter/setter");
	if( tbl.tbl.colptr.{{ $col.Name }} ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: tbl.tbl.colptr.{{ $col.Name }}: not initialized to null"); } {{ end }}{{/* columns */}}
	{{ range $i,$col := .Columns }}
	test_table_columnpreset_{{ $db.Name }}_{{ $tbl.Name }}(&tbl);
	test_table_checkpreset_{{ $db.Name }}_{{ $tbl.Name }}(&tbl);

	SET_COLUMN_NULL(tbl,{{ $col.Name }});
	if( tbl.tbl.colptr.{{ $col.Name }} ) {
		LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}.{{ $col.Name }}: SET_COLUMN_NULL: not null"); }	{{ end }}{{/* columns */}}
}

static void test_table_uniq_{{ $db.Name }}_{{ $tbl.Name }}() {
	LOG_DEBUG("checking column {{ $db.Name }}.{{ $tbl.Name }} unique keys");

	UpsertStmt stmt;
	upsertstmt_{{ $db.Name }}_{{ $tbl.Name }}(&stmt);

	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);
	if( tbl.tbl.nunique != stmt.nuniq || stmt.nuniq != {{ len $tbl.UniqueKeys }} ) {
		LOGF_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid uniq key count (%zu,%zu,%d)",tbl.tbl.nunique,stmt.nuniq,{{ len $tbl.UniqueKeys }}); }

	for(size_t uk = 0; uk < stmt.nuniq; uk++) {
		if( tbl.tbl.uniquekeys[uk]->ncols != stmt.uniqs[uk]->ncols ) {
			LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid uniq key column count"); }
		for(size_t col = 0; col < stmt.uniqs[uk]->ncols; col++) {
			if( strcmp(tbl.tbl.uniquekeys[uk]->cols[col],stmt.uniqs[uk]->cols[col]) != 0 ) {
				LOG_FATAL(1,"{{ $db.Name }}.{{ $tbl.Name }}: invalid uniq key column name"); }
		}
	}
}

static void test_table_{{ $db.Name }}_{{ $tbl.Name }}() {
	
	test_table_buffer_size_{{ $db.Name }}_{{ $tbl.Name }}();

	LOG_DEBUG("checking table {{ $db.Name }}.{{ $tbl.Name }} instanciation");
	TABLE_STRUCT({{ $db.Name }},{{ $tbl.Name }},tbl);
	
	test_table_def_{{ $db.Name }}_{{ $tbl.Name }}(tbl.tbl.def);
	test_table_indexes_{{ $db.Name }}_{{ $tbl.Name }}(&tbl);
	test_table_coldef_{{ $db.Name }}_{{ $tbl.Name }}(&tbl);
	test_table_getset_{{ $db.Name }}_{{ $tbl.Name }}();
	test_table_uniq_{{ $db.Name }}_{{ $tbl.Name }}();
}
{{ end }}{{/* tables */}}{{ end }}{{/* databases */}}

void test_tables_static() { {{ $td := . }}{{ range $db := .L.Databases }}
	LOG_DEBUG("checking database {{ $db.Name }}");{{ range $tbl := $db.Tables }}
	test_table_{{ $db.Name }}_{{ $tbl.Name }}();{{ end }}{{/* tables */}}{{ end }}{{/* databases */}}
	LOG_INFO("all static checks on generated tables: SUCCESS");
}

void test_tables_db(DBHandle *dbh) { {{ $td := . }}{{ range $db := .L.Databases }}
	LOG_DEBUG("checking database {{ $db.Name }}");{{ range $tbl := $db.Tables }}
	
	if(strcmp("complextable3","{{ $tbl.Name }}")  == 0) {
		return; }

	LOG_DEBUG("checking table {{ $db.Name }}");
	test_table_delete_{{ $db.Name }}_{{ $tbl.Name }}(dbh);
	test_table_insert{{ $db.Name }}_{{ $tbl.Name }}(dbh);
	test_table_select_{{ $db.Name }}_{{ $tbl.Name }}(dbh);
	test_table_update_{{ $db.Name }}_{{ $tbl.Name }}(dbh);
	test_table_upsert_{{ $db.Name }}_{{ $tbl.Name }}(dbh);
	test_table_delete_{{ $db.Name }}_{{ $tbl.Name }}(dbh);{{ end }}{{/* tables */}}
	LOG_DEBUG("all tables for {{ $db.Name }}: SUCCESS");{{ end }}{{/* databases */}}
	LOG_INFO("all dynamic checks on generated tables: SUCCESS");
}

#endif
